<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Cubes ASCII Wireframes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: black; color: white; font-family: monospace; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        pre { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; font-size: 8px; line-height: 8px; white-space: pre-wrap; overflow: hidden; }
    </style>
</head>
<body>
    <script>
        let scene = new THREE.Scene();
        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        let renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let cubes = [];
        let cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });

        // Track the previous window size
        let previousWidth = window.innerWidth;
        let previousHeight = window.innerHeight;

        // Function to create and place cubes within the window
        function createCube() {
            let geometry = new THREE.BoxGeometry();
            let cube = new THREE.Mesh(geometry, cubeMaterial);

            // Randomize positions based on the current window size
            let rangeX = window.innerWidth / 2; // X range based on window width
            let rangeY = window.innerHeight / 2; // Y range based on window height
            cube.position.set(
                Math.random() * rangeX - rangeX / 2,  // X position
                Math.random() * rangeY - rangeY / 2,  // Y position
                Math.random() * 40 - 20               // Z position (depth)
            );
            cube.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            scene.add(cube);
            cubes.push(cube);
        }

        camera.position.z = 20;

        let asciiContainer = document.createElement("pre");
        document.body.appendChild(asciiContainer);

        function renderToASCII() {
            // Create a temporary 2D canvas for ASCII rendering
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = renderer.domElement.width;
            tempCanvas.height = renderer.domElement.height;
            const tempCtx = tempCanvas.getContext("2d");

            // Draw the WebGL renderer's output onto the 2D canvas
            tempCtx.drawImage(renderer.domElement, 0, 0, tempCanvas.width, tempCanvas.height);

            // Get the image data from the 2D canvas
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
            const chars = " .:-=+*%@#";
            let ascii = "";

            // Convert the image data to ASCII
            for (let y = 0; y < tempCanvas.height; y += 10) {
                for (let x = 0; x < tempCanvas.width; x += 5) {
                    const i = (y * tempCanvas.width + x) * 4;
                    const brightness = (imageData[i] + imageData[i + 1] + imageData[i + 2]) / 3;
                    const charIndex = Math.floor((brightness / 255) * (chars.length - 1));
                    ascii += chars[charIndex];
                }
                ascii += "\n";
            }

            // Update the ASCII container
            asciiContainer.textContent = ascii;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Add a new cube periodically to maintain a constant stream
            if (Math.random() < 0.5) {
                createCube();
            }

            cubes.forEach(cube => {
                cube.position.y -= 0.03;
                cube.rotation.x += 0.001;
                cube.rotation.y += 0.001;
                if (cube.position.y < -20) {
                    cube.position.y = 20;
                    cube.position.x = Math.random() * 40 - 20;
                    cube.position.z = Math.random() * 40 - 20;
                    cube.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                }
            });

            renderer.render(scene, camera);
            renderToASCII();
        }

        // Handle window resize
        function onWindowResize() {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            // Only update if the window size has actually changed
            if (newWidth !== previousWidth || newHeight !== previousHeight) {
                // Update renderer and camera
                renderer.setSize(newWidth, newHeight);
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();

                // Update the previous window size
                previousWidth = newWidth;
                previousHeight = newHeight;
            }
        }

        // Start the animation loop
        animate();

        // Add resize event listener
        window.addEventListener("resize", onWindowResize);
    </script>
</body>
</html>